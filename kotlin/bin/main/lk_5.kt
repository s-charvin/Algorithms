package solution._5

class Solution {
    fun longestPalindrome(s: String): String {
        // ===== 第一步：判断题型特征 =====
        // 观察问题特征: 找到字符串 s 中的最长回文子串
        //    - 回文串具有左右对称的特性
        //    - 短回文串只需要左右新增字符为相同字符, 则仍然是回文串
        //    - 特殊情况, 单字符是回文, 双字符如果两字符相同也是回文
        //
        // 判断适用动态规划的依据:
        //   重叠子问题 - 更长子串的判断依赖于内部较短子串是否为回文
        //   最优子结构 - 最长回文串可以由较短的回文串扩展而来

        // ===== 第二步：定义状态 =====
        // 单序列型, 双状态: dp[i]表示前i个元素的状态
        // 双序列型: dp[i][j] 表示两个序列前 i、j 元素的状态
        //
        // 可以定义二维状态数组 dp[i][j] 表示子串 s[i...j] 是否为回文

        // ===== 第三步: 构建状态转移方程 =====
        //
        // 假设 dp[i+1][j-1], 则计算 dp[i][j] 需要注意以下情况:
        //    - j 必须大于等于 i
        //    - 当 j - i <= 2 时, 判断 s[i][j] 是否相等即可判断是否是回文.
        //    - 当 j - i > 2 时, 当 dp[i+1][j-1] 是回文, 且 s[i][j] 相等则是回文, 否则不是.

        // ===== 第四步: 初始化边界条件 =====
        // 起点, 边界, 异常值
        //
        // 所有单字符一定是回文
        // 长度为 2 的判断字符是否相等即可

        // ===== 第五步: 确定遍历顺序 =====
        // 正序, 逆序, 多维
        // 二维遍历, 同时 i 逆序递减遍历, j 顺序递增遍历, j > i, 保证遍历过程中 dp[i+1][j-1] 计算完毕.

        if (s.length == 1) {
            return s
        }

        if (s.length == 2 && s[0] == s[1]) {
            return s
        } else if (s.length == 2) {
            return s.substring(0, 1)
        }

        val n = s.length
        val i = n-1
        var j = i
        val dp = Array(n-1){ IntArray(n-1) }

        return ""
    }
}
