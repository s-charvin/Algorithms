
class Solution {
    fun findLength(nums1: IntArray, nums2: IntArray): Int {
        // ===== 第一步：判断题型特征 =====
        // 观察问题特征:
        // 返回两个数组中 公共的, 长度最长的子数组的长度.
        // 数组长度越长, 则公共的子数组长度就更难找. 可以尝试从短的开始, 能不能递推长的.
        //
        // 判断适用动态规划的依据:
        //   重叠子问题 - 较长的公共子数组的判断依赖较短子数组的结果
        //   最优子结构 - 全局最优解可以通过子问题的最优解递推得到
        //   状态可定义 - 可以用二维状态表示两个数组的匹配长度
        //      假设数组 A[n-2], B[m-2], 子数组长度为 l
        //      则 A[n-1] 到 B[m-1], 子数组长度 l(+1), 是否加一取决于新增字符是否相等
        //
        //
        // ===== 第二步：定义状态 =====
        // 单序列型, 双状态: dp[i]表示前i个元素的状态
        // 双序列型: dp[i][j] 表示两个序列前 i、j 元素的状态
        //
        // 将以 A[i-1] 和 B[j-1] 结尾的最长公共子数组的长度表示为 dp[i][j]
        //
        // ===== 第三步: 构建状态转移方程 =====
        // if A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] + 1
        // else: dp[i][j] = 0
        //
        // ===== 第四步: 初始化边界条件 =====
        // 起点, 边界, 异常值
        // 当 i=0 或 j=0 时(空数组情况): dp[0][j] = 0, dp[i][0] = 0
        //
        //
        // ===== 第五步: 确定遍历顺序 =====
        // 正序, 逆序, 多维
        // 长度递增, 正序遍历
        //

        val n = nums1.size
        val m = nums2.size
        var maxL = 0
        val dp = Array(n+1) { BooleanArray(m+1) }

        for (i in 0..n) {
            dp[i][0] = 0
        }

        for (j in 0..m) {
            dp[0][j] = 0
        }

        for(i in 1..n) {
            for(j in 1..m){
                if(nums1[i-1] == nums2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1
                    maxL = max(maxL, dp[i][j])
                }else {
                    dp[i][j] = 0
                }
            }
        }

        return maxL
    }
}
